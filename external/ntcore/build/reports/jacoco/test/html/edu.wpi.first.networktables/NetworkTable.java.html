<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NetworkTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ntcore</a> &gt; <a href="index.source.html" class="el_package">edu.wpi.first.networktables</a> &gt; <span class="el_source">NetworkTable.java</span></div><h1>NetworkTable.java</h1><pre class="source lang-java linenums">// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package edu.wpi.first.networktables;

import edu.wpi.first.util.protobuf.Protobuf;
import edu.wpi.first.util.struct.Struct;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.function.Consumer;
import us.hebi.quickbuf.ProtoMessage;

/** A network table that knows its subtable path. */
@SuppressWarnings(&quot;PMD.CouplingBetweenObjects&quot;)
public final class NetworkTable {
  /** The path separator for sub-tables and keys. */
  public static final char PATH_SEPARATOR = '/';

  private final String m_path;
  private final String m_pathWithSep;
  private final NetworkTableInstance m_inst;

  /**
   * Gets the &quot;base name&quot; of a key. For example, &quot;/foo/bar&quot; becomes &quot;bar&quot;. If the key has a trailing
   * slash, returns an empty string.
   *
   * @param key key
   * @return base name
   */
  public static String basenameKey(String key) {
<span class="fc" id="L38">    final int slash = key.lastIndexOf(PATH_SEPARATOR);</span>
<span class="fc bfc" id="L39" title="All 2 branches covered.">    if (slash == -1) {</span>
<span class="fc" id="L40">      return key;</span>
    }
<span class="fc" id="L42">    return key.substring(slash + 1);</span>
  }

  /**
   * Normalizes an network table key to contain no consecutive slashes and optionally start with a
   * leading slash. For example:
   *
   * &lt;pre&gt;&lt;code&gt;
   * normalizeKey(&quot;/foo/bar&quot;, true)  == &quot;/foo/bar&quot;
   * normalizeKey(&quot;foo/bar&quot;, true)   == &quot;/foo/bar&quot;
   * normalizeKey(&quot;/foo/bar&quot;, false) == &quot;foo/bar&quot;
   * normalizeKey(&quot;foo//bar&quot;, false) == &quot;foo/bar&quot;
   * &lt;/code&gt;&lt;/pre&gt;
   *
   * @param key the key to normalize
   * @param withLeadingSlash whether or not the normalized key should begin with a leading slash
   * @return normalized key
   */
  public static String normalizeKey(String key, boolean withLeadingSlash) {
    String normalized;
<span class="fc bfc" id="L62" title="All 2 branches covered.">    if (withLeadingSlash) {</span>
<span class="fc" id="L63">      normalized = PATH_SEPARATOR + key;</span>
    } else {
<span class="fc" id="L65">      normalized = key;</span>
    }
<span class="fc" id="L67">    normalized = normalized.replaceAll(PATH_SEPARATOR + &quot;{2,}&quot;, String.valueOf(PATH_SEPARATOR));</span>

<span class="fc bfc" id="L69" title="All 4 branches covered.">    if (!withLeadingSlash &amp;&amp; normalized.charAt(0) == PATH_SEPARATOR) {</span>
      // remove leading slash, if present
<span class="fc" id="L71">      normalized = normalized.substring(1);</span>
    }
<span class="fc" id="L73">    return normalized;</span>
  }

  /**
   * Normalizes a network table key to start with exactly one leading slash (&quot;/&quot;) and contain no
   * consecutive slashes. For example, {@code &quot;//foo/bar/&quot;} becomes {@code &quot;/foo/bar/&quot;} and {@code
   * &quot;///a/b/c&quot;} becomes {@code &quot;/a/b/c&quot;}.
   *
   * &lt;p&gt;This is equivalent to {@code normalizeKey(key, true)}
   *
   * @param key the key to normalize
   * @return normalized key
   */
  public static String normalizeKey(String key) {
<span class="fc" id="L87">    return normalizeKey(key, true);</span>
  }

  /**
   * Gets a list of the names of all the super tables of a given key. For example, the key
   * &quot;/foo/bar/baz&quot; has a hierarchy of &quot;/&quot;, &quot;/foo&quot;, &quot;/foo/bar&quot;, and &quot;/foo/bar/baz&quot;.
   *
   * @param key the key
   * @return List of super tables
   */
  public static List&lt;String&gt; getHierarchy(String key) {
<span class="fc" id="L98">    final String normal = normalizeKey(key, true);</span>
<span class="fc" id="L99">    List&lt;String&gt; hierarchy = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">    if (normal.length() == 1) {</span>
<span class="fc" id="L101">      hierarchy.add(normal);</span>
<span class="fc" id="L102">      return hierarchy;</span>
    }
<span class="fc" id="L104">    for (int i = 1; ; i = normal.indexOf(PATH_SEPARATOR, i + 1)) {</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">      if (i == -1) {</span>
        // add the full key
<span class="fc" id="L107">        hierarchy.add(normal);</span>
<span class="fc" id="L108">        break;</span>
      } else {
<span class="fc" id="L110">        hierarchy.add(normal.substring(0, i));</span>
      }
    }
<span class="fc" id="L113">    return hierarchy;</span>
  }

  /** Constructor. Use NetworkTableInstance.getTable() or getSubTable() instead. */
<span class="fc" id="L117">  NetworkTable(NetworkTableInstance inst, String path) {</span>
<span class="fc" id="L118">    m_path = path;</span>
<span class="fc" id="L119">    m_pathWithSep = path + PATH_SEPARATOR;</span>
<span class="fc" id="L120">    m_inst = inst;</span>
<span class="fc" id="L121">  }</span>

  /**
   * Gets the instance for the table.
   *
   * @return Instance
   */
  public NetworkTableInstance getInstance() {
<span class="nc" id="L129">    return m_inst;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L134">    return &quot;NetworkTable: &quot; + m_path;</span>
  }

  /**
   * Get (generic) topic.
   *
   * @param name topic name
   * @return Topic
   */
  public Topic getTopic(String name) {
<span class="nc" id="L144">    return m_inst.getTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get boolean topic.
   *
   * @param name topic name
   * @return BooleanTopic
   */
  public BooleanTopic getBooleanTopic(String name) {
<span class="nc" id="L154">    return m_inst.getBooleanTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get long topic.
   *
   * @param name topic name
   * @return IntegerTopic
   */
  public IntegerTopic getIntegerTopic(String name) {
<span class="nc" id="L164">    return m_inst.getIntegerTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get float topic.
   *
   * @param name topic name
   * @return FloatTopic
   */
  public FloatTopic getFloatTopic(String name) {
<span class="nc" id="L174">    return m_inst.getFloatTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get double topic.
   *
   * @param name topic name
   * @return DoubleTopic
   */
  public DoubleTopic getDoubleTopic(String name) {
<span class="nc" id="L184">    return m_inst.getDoubleTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get String topic.
   *
   * @param name topic name
   * @return StringTopic
   */
  public StringTopic getStringTopic(String name) {
<span class="nc" id="L194">    return m_inst.getStringTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get raw topic.
   *
   * @param name topic name
   * @return RawTopic
   */
  public RawTopic getRawTopic(String name) {
<span class="nc" id="L204">    return m_inst.getRawTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get boolean[] topic.
   *
   * @param name topic name
   * @return BooleanArrayTopic
   */
  public BooleanArrayTopic getBooleanArrayTopic(String name) {
<span class="nc" id="L214">    return m_inst.getBooleanArrayTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get long[] topic.
   *
   * @param name topic name
   * @return IntegerArrayTopic
   */
  public IntegerArrayTopic getIntegerArrayTopic(String name) {
<span class="nc" id="L224">    return m_inst.getIntegerArrayTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get float[] topic.
   *
   * @param name topic name
   * @return FloatArrayTopic
   */
  public FloatArrayTopic getFloatArrayTopic(String name) {
<span class="nc" id="L234">    return m_inst.getFloatArrayTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get double[] topic.
   *
   * @param name topic name
   * @return DoubleArrayTopic
   */
  public DoubleArrayTopic getDoubleArrayTopic(String name) {
<span class="nc" id="L244">    return m_inst.getDoubleArrayTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get String[] topic.
   *
   * @param name topic name
   * @return StringArrayTopic
   */
  public StringArrayTopic getStringArrayTopic(String name) {
<span class="nc" id="L254">    return m_inst.getStringArrayTopic(m_pathWithSep + name);</span>
  }

  /**
   * Get protobuf-encoded value topic.
   *
   * @param &lt;T&gt; value class (inferred from proto)
   * @param &lt;MessageType&gt; protobuf message type (inferred from proto)
   * @param name topic name
   * @param proto protobuf serialization implementation
   * @return ProtobufTopic
   */
  public &lt;T, MessageType extends ProtoMessage&lt;?&gt;&gt; ProtobufTopic&lt;T&gt; getProtobufTopic(
      String name, Protobuf&lt;T, MessageType&gt; proto) {
<span class="nc" id="L268">    return m_inst.getProtobufTopic(m_pathWithSep + name, proto);</span>
  }

  /**
   * Get struct-encoded value topic.
   *
   * @param &lt;T&gt; value class (inferred from struct)
   * @param name topic name
   * @param struct struct serialization implementation
   * @return StructTopic
   */
  public &lt;T&gt; StructTopic&lt;T&gt; getStructTopic(String name, Struct&lt;T&gt; struct) {
<span class="nc" id="L280">    return m_inst.getStructTopic(m_pathWithSep + name, struct);</span>
  }

  /**
   * Get struct-encoded value array topic.
   *
   * @param &lt;T&gt; value class (inferred from struct)
   * @param name topic name
   * @param struct struct serialization implementation
   * @return StructTopic
   */
  public &lt;T&gt; StructArrayTopic&lt;T&gt; getStructArrayTopic(String name, Struct&lt;T&gt; struct) {
<span class="nc" id="L292">    return m_inst.getStructArrayTopic(m_pathWithSep + name, struct);</span>
  }

<span class="fc" id="L295">  private final ConcurrentMap&lt;String, NetworkTableEntry&gt; m_entries = new ConcurrentHashMap&lt;&gt;();</span>

  /**
   * Gets the entry for a sub key.
   *
   * @param key the key name
   * @return Network table entry.
   */
  public NetworkTableEntry getEntry(String key) {
<span class="nc" id="L304">    NetworkTableEntry entry = m_entries.get(key);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">    if (entry == null) {</span>
<span class="nc" id="L306">      entry = m_inst.getEntry(m_pathWithSep + key);</span>
<span class="nc" id="L307">      NetworkTableEntry oldEntry = m_entries.putIfAbsent(key, entry);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">      if (oldEntry != null) {</span>
<span class="nc" id="L309">        entry = oldEntry;</span>
      }
    }
<span class="nc" id="L312">    return entry;</span>
  }

  /**
   * Returns the table at the specified key. If there is no table at the specified key, it will
   * create a new table
   *
   * @param key the name of the table relative to this one
   * @return a sub table relative to this one
   */
  public NetworkTable getSubTable(String key) {
<span class="fc" id="L323">    return new NetworkTable(m_inst, m_pathWithSep + key);</span>
  }

  /**
   * Checks the table and tells if it contains the specified key.
   *
   * @param key the key to search for
   * @return true if the table as a value assigned to the given key
   */
  public boolean containsKey(String key) {
<span class="nc bnc" id="L333" title="All 4 branches missed.">    return !(&quot;&quot;.equals(key)) &amp;&amp; getTopic(key).exists();</span>
  }

  /**
   * Checks the table and tells if it contains the specified sub table.
   *
   * @param key the key to search for
   * @return true if there is a subtable with the key which contains at least one key/subtable of
   *     its own
   */
  public boolean containsSubTable(String key) {
<span class="nc" id="L344">    Topic[] topics = m_inst.getTopics(m_pathWithSep + key + PATH_SEPARATOR, 0);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">    return topics.length != 0;</span>
  }

  /**
   * Gets topic information for all keys in the table (not including sub-tables).
   *
   * @param types bitmask of types (NetworkTableType values); 0 is treated as a &quot;don't care&quot;.
   * @return topic information for keys currently in the table
   */
  public List&lt;TopicInfo&gt; getTopicInfo(int types) {
<span class="nc" id="L355">    List&lt;TopicInfo&gt; infos = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L356">    int prefixLen = m_path.length() + 1;</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">    for (TopicInfo info : m_inst.getTopicInfo(m_pathWithSep, types)) {</span>
<span class="nc" id="L358">      String relativeKey = info.name.substring(prefixLen);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">      if (relativeKey.indexOf(PATH_SEPARATOR) != -1) {</span>
<span class="nc" id="L360">        continue;</span>
      }
<span class="nc" id="L362">      infos.add(info);</span>
    }
<span class="nc" id="L364">    return infos;</span>
  }

  /**
   * Gets topic information for all keys in the table (not including sub-tables).
   *
   * @return topic information for keys currently in the table
   */
  public List&lt;TopicInfo&gt; getTopicInfo() {
<span class="nc" id="L373">    return getTopicInfo(0);</span>
  }

  /**
   * Gets all topics in the table (not including sub-tables).
   *
   * @param types bitmask of types (NetworkTableType values); 0 is treated as a &quot;don't care&quot;.
   * @return topic for keys currently in the table
   */
  public List&lt;Topic&gt; getTopics(int types) {
<span class="nc" id="L383">    List&lt;Topic&gt; topics = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L384">    int prefixLen = m_path.length() + 1;</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">    for (TopicInfo info : m_inst.getTopicInfo(m_pathWithSep, types)) {</span>
<span class="nc" id="L386">      String relativeKey = info.name.substring(prefixLen);</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">      if (relativeKey.indexOf(PATH_SEPARATOR) != -1) {</span>
<span class="nc" id="L388">        continue;</span>
      }
<span class="nc" id="L390">      topics.add(info.getTopic());</span>
    }
<span class="nc" id="L392">    return topics;</span>
  }

  /**
   * Gets all topics in the table (not including sub-tables).
   *
   * @return topic for keys currently in the table
   */
  public List&lt;Topic&gt; getTopics() {
<span class="nc" id="L401">    return getTopics(0);</span>
  }

  /**
   * Gets all keys in the table (not including sub-tables).
   *
   * @param types bitmask of types; 0 is treated as a &quot;don't care&quot;.
   * @return keys currently in the table
   */
  public Set&lt;String&gt; getKeys(int types) {
<span class="nc" id="L411">    Set&lt;String&gt; keys = new HashSet&lt;&gt;();</span>
<span class="nc" id="L412">    int prefixLen = m_path.length() + 1;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">    for (TopicInfo info : m_inst.getTopicInfo(m_pathWithSep, types)) {</span>
<span class="nc" id="L414">      String relativeKey = info.name.substring(prefixLen);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">      if (relativeKey.indexOf(PATH_SEPARATOR) != -1) {</span>
<span class="nc" id="L416">        continue;</span>
      }
<span class="nc" id="L418">      keys.add(relativeKey);</span>
    }
<span class="nc" id="L420">    return keys;</span>
  }

  /**
   * Gets all keys in the table (not including sub-tables).
   *
   * @return keys currently in the table
   */
  public Set&lt;String&gt; getKeys() {
<span class="nc" id="L429">    return getKeys(0);</span>
  }

  /**
   * Gets the names of all subtables in the table.
   *
   * @return subtables currently in the table
   */
  public Set&lt;String&gt; getSubTables() {
<span class="nc" id="L438">    Set&lt;String&gt; keys = new HashSet&lt;&gt;();</span>
<span class="nc" id="L439">    int prefixLen = m_path.length() + 1;</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">    for (TopicInfo info : m_inst.getTopicInfo(m_pathWithSep, 0)) {</span>
<span class="nc" id="L441">      String relativeKey = info.name.substring(prefixLen);</span>
<span class="nc" id="L442">      int endSubTable = relativeKey.indexOf(PATH_SEPARATOR);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">      if (endSubTable == -1) {</span>
<span class="nc" id="L444">        continue;</span>
      }
<span class="nc" id="L446">      keys.add(relativeKey.substring(0, endSubTable));</span>
    }
<span class="nc" id="L448">    return keys;</span>
  }

  /**
   * Put a value in the table.
   *
   * @param key the key to be assigned to
   * @param value the value that will be assigned
   * @return False if the table key already exists with a different type
   */
  public boolean putValue(String key, NetworkTableValue value) {
<span class="nc" id="L459">    return getEntry(key).setValue(value);</span>
  }

  /**
   * Gets the current value in the table, setting it if it does not exist.
   *
   * @param key the key
   * @param defaultValue the default value to set if key doesn't exist.
   * @return False if the table key exists with a different type
   */
  public boolean setDefaultValue(String key, NetworkTableValue defaultValue) {
<span class="nc" id="L470">    return getEntry(key).setDefaultValue(defaultValue);</span>
  }

  /**
   * Gets the value associated with a key as an object.
   *
   * @param key the key of the value to look up
   * @return the value associated with the given key, or nullptr if the key does not exist
   */
  public NetworkTableValue getValue(String key) {
<span class="nc" id="L480">    return getEntry(key).getValue();</span>
  }

  /**
   * Get the path of the NetworkTable.
   *
   * @return The path of the NetworkTable.
   */
  public String getPath() {
<span class="nc" id="L489">    return m_path;</span>
  }

  /** A listener that listens to events on topics in a {@link NetworkTable}. */
  @FunctionalInterface
  public interface TableEventListener {
    /**
     * Called when an event occurs on a topic in a {@link NetworkTable}.
     *
     * @param table the table the topic exists in
     * @param key the key associated with the topic that changed
     * @param event the event
     */
    void accept(NetworkTable table, String key, NetworkTableEvent event);
  }

  /**
   * Listen to topics only within this table.
   *
   * @param eventKinds set of event kinds to listen to
   * @param listener listener to add
   * @return Listener handle
   */
  public int addListener(EnumSet&lt;NetworkTableEvent.Kind&gt; eventKinds, TableEventListener listener) {
<span class="fc" id="L513">    final int prefixLen = m_path.length() + 1;</span>
<span class="fc" id="L514">    return m_inst.addListener(</span>
        new String[] {m_pathWithSep},
        eventKinds,
        event -&gt; {
<span class="fc" id="L518">          String topicName = null;</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">          if (event.topicInfo != null) {</span>
<span class="fc" id="L520">            topicName = event.topicInfo.name;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">          } else if (event.valueData != null) {</span>
<span class="nc" id="L522">            topicName = event.valueData.getTopic().getName();</span>
          }
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">          if (topicName == null) {</span>
<span class="nc" id="L525">            return;</span>
          }
<span class="fc" id="L527">          String relativeKey = topicName.substring(prefixLen);</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">          if (relativeKey.indexOf(PATH_SEPARATOR) != -1) {</span>
            // part of a sub table
<span class="fc" id="L530">            return;</span>
          }
<span class="fc" id="L532">          listener.accept(this, relativeKey, event);</span>
<span class="fc" id="L533">        });</span>
  }

  /**
   * Listen to a single key.
   *
   * @param key the key name
   * @param eventKinds set of event kinds to listen to
   * @param listener listener to add
   * @return Listener handle
   */
  public int addListener(
      String key, EnumSet&lt;NetworkTableEvent.Kind&gt; eventKinds, TableEventListener listener) {
<span class="nc" id="L546">    NetworkTableEntry entry = getEntry(key);</span>
<span class="nc" id="L547">    return m_inst.addListener(entry, eventKinds, event -&gt; listener.accept(this, key, event));</span>
  }

  /** A listener that listens to new tables in a {@link NetworkTable}. */
  @FunctionalInterface
  public interface SubTableListener {
    /**
     * Called when a new table is created within a {@link NetworkTable}.
     *
     * @param parent the parent of the table
     * @param name the name of the new table
     * @param table the new table
     */
    void tableCreated(NetworkTable parent, String name, NetworkTable table);
  }

  /**
   * Listen for sub-table creation. This calls the listener once for each newly created sub-table.
   * It immediately calls the listener for any existing sub-tables.
   *
   * @param listener listener to add
   * @return Listener handle
   */
  public int addSubTableListener(SubTableListener listener) {
<span class="fc" id="L571">    final int prefixLen = m_path.length() + 1;</span>
<span class="fc" id="L572">    final NetworkTable parent = this;</span>

<span class="fc" id="L574">    return m_inst.addListener(</span>
        new String[] {m_pathWithSep},
<span class="fc" id="L576">        EnumSet.of(NetworkTableEvent.Kind.kPublish, NetworkTableEvent.Kind.kImmediate),</span>
<span class="fc" id="L577">        new Consumer&lt;NetworkTableEvent&gt;() {</span>
<span class="fc" id="L578">          final Set&lt;String&gt; m_notifiedTables = new HashSet&lt;&gt;();</span>

          @Override
          public void accept(NetworkTableEvent event) {
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">            if (event.topicInfo == null) {</span>
<span class="nc" id="L583">              return; // should not happen</span>
            }
<span class="fc" id="L585">            String relativeKey = event.topicInfo.name.substring(prefixLen);</span>
<span class="fc" id="L586">            int endSubTable = relativeKey.indexOf(PATH_SEPARATOR);</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">            if (endSubTable == -1) {</span>
<span class="fc" id="L588">              return;</span>
            }
<span class="fc" id="L590">            String subTableKey = relativeKey.substring(0, endSubTable);</span>
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">            if (m_notifiedTables.contains(subTableKey)) {</span>
<span class="nc" id="L592">              return;</span>
            }
<span class="fc" id="L594">            m_notifiedTables.add(subTableKey);</span>
<span class="fc" id="L595">            listener.tableCreated(parent, subTableKey, parent.getSubTable(subTableKey));</span>
<span class="fc" id="L596">          }</span>
        });
  }

  /**
   * Remove a listener.
   *
   * @param listener listener handle
   */
  public void removeListener(int listener) {
<span class="nc" id="L606">    m_inst.removeListener(listener);</span>
<span class="nc" id="L607">  }</span>

  @Override
  public boolean equals(Object other) {
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">    if (other == this) {</span>
<span class="fc" id="L612">      return true;</span>
    }
<span class="nc bnc" id="L614" title="All 2 branches missed.">    if (!(other instanceof NetworkTable)) {</span>
<span class="nc" id="L615">      return false;</span>
    }
<span class="nc" id="L617">    NetworkTable ntOther = (NetworkTable) other;</span>
<span class="nc bnc" id="L618" title="All 4 branches missed.">    return m_inst.equals(ntOther.m_inst) &amp;&amp; m_path.equals(ntOther.m_path);</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L623">    return Objects.hash(m_inst, m_path);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>
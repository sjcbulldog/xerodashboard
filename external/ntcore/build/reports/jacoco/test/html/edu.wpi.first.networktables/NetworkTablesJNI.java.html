<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NetworkTablesJNI.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ntcore</a> &gt; <a href="index.source.html" class="el_package">edu.wpi.first.networktables</a> &gt; <span class="el_source">NetworkTablesJNI.java</span></div><h1>NetworkTablesJNI.java</h1><pre class="source lang-java linenums">// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package edu.wpi.first.networktables;

import edu.wpi.first.util.RuntimeLoader;
import edu.wpi.first.util.datalog.DataLog;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.EnumSet;
import java.util.OptionalLong;
import java.util.concurrent.atomic.AtomicBoolean;

<span class="nc" id="L15">public final class NetworkTablesJNI {</span>
<span class="fc" id="L16">  static boolean libraryLoaded = false;</span>
<span class="fc" id="L17">  static RuntimeLoader&lt;NetworkTablesJNI&gt; loader = null;</span>

<span class="nc" id="L19">  public static class Helper {</span>
<span class="fc" id="L20">    private static AtomicBoolean extractOnStaticLoad = new AtomicBoolean(true);</span>

    public static boolean getExtractOnStaticLoad() {
<span class="fc" id="L23">      return extractOnStaticLoad.get();</span>
    }

    public static void setExtractOnStaticLoad(boolean load) {
<span class="nc" id="L27">      extractOnStaticLoad.set(load);</span>
<span class="nc" id="L28">    }</span>
  }

  static {
<span class="pc bpc" id="L32" title="1 of 2 branches missed.">    if (Helper.getExtractOnStaticLoad()) {</span>
      try {
<span class="fc" id="L34">        loader =</span>
            new RuntimeLoader&lt;&gt;(
<span class="fc" id="L36">                &quot;ntcorejni&quot;, RuntimeLoader.getDefaultExtractionRoot(), NetworkTablesJNI.class);</span>
<span class="fc" id="L37">        loader.loadLibrary();</span>
<span class="nc" id="L38">      } catch (IOException ex) {</span>
<span class="nc" id="L39">        ex.printStackTrace();</span>
<span class="nc" id="L40">        System.exit(1);</span>
<span class="fc" id="L41">      }</span>
<span class="fc" id="L42">      libraryLoaded = true;</span>
    }
<span class="fc" id="L44">  }</span>

  /**
   * Force load the library.
   *
   * @throws IOException if the library fails to load
   */
  public static synchronized void forceLoad() throws IOException {
<span class="nc bnc" id="L52" title="All 2 branches missed.">    if (libraryLoaded) {</span>
<span class="nc" id="L53">      return;</span>
    }
<span class="nc" id="L55">    loader =</span>
        new RuntimeLoader&lt;&gt;(
<span class="nc" id="L57">            &quot;ntcorejni&quot;, RuntimeLoader.getDefaultExtractionRoot(), NetworkTablesJNI.class);</span>
<span class="nc" id="L58">    loader.loadLibrary();</span>
<span class="nc" id="L59">    libraryLoaded = true;</span>
<span class="nc" id="L60">  }</span>

  private static PubSubOptions buildOptions(PubSubOption... options) {
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">    if (options.length == 0) {</span>
<span class="fc" id="L64">      return null;  // optimize common case (JNI checks for null)</span>
    }
<span class="nc" id="L66">    return new PubSubOptions(options);</span>
  }

  public static native int getDefaultInstance();

  public static native int createInstance();

  public static native void destroyInstance(int inst);

  public static native int getInstanceFromHandle(int handle);

  private static native int getEntryImpl(
      int topic, int type, String typeStr, PubSubOptions options);

  public static native int getEntry(int inst, String key);

  public static int getEntry(
      int topic, int type, String typeStr, PubSubOptions options) {
<span class="nc" id="L84">    return getEntryImpl(topic, type, typeStr, options);</span>
  }

  public static int getEntry(
      int topic, int type, String typeStr, PubSubOption... options) {
<span class="fc" id="L89">    return getEntryImpl(topic, type, typeStr, buildOptions(options));</span>
  }

  public static native String getEntryName(int entry);

  public static native long getEntryLastChange(int entry);

  public static native int getType(int entry);

  /* Topic functions */

  public static native int[] getTopics(int inst, String prefix, int types);

  public static native int[] getTopicsStr(int inst, String prefix, String[] types);

  public static native TopicInfo[] getTopicInfos(
      NetworkTableInstance instObject, int inst, String prefix, int types);

  public static native TopicInfo[] getTopicInfosStr(
      NetworkTableInstance instObject, int inst, String prefix, String[] types);

  public static native int getTopic(int inst, String name);

  public static native String getTopicName(int topic);

  public static native int getTopicType(int topic);

  public static native void setTopicPersistent(int topic, boolean value);

  public static native boolean getTopicPersistent(int topic);

  public static native void setTopicRetained(int topic, boolean value);

  public static native boolean getTopicRetained(int topic);

  public static native String getTopicTypeString(int topic);

  public static native boolean getTopicExists(int topic);

  public static native String getTopicProperty(int topic, String name);

  public static native void setTopicProperty(int topic, String name, String value);

  public static native void deleteTopicProperty(int topic, String name);

  public static native String getTopicProperties(int topic);

  public static native void setTopicProperties(int topic, String properties);

  public static native int subscribe(
      int topic, int type, String typeStr, PubSubOptions options);

  public static int subscribe(
      int topic, int type, String typeStr, PubSubOption... options) {
<span class="nc" id="L143">    return subscribe(topic, type, typeStr, buildOptions(options));</span>
  }

  public static native void unsubscribe(int sub);

  public static native int publish(
      int topic, int type, String typeStr, PubSubOptions options);

  public static int publish(
      int topic, int type, String typeStr, PubSubOption... options) {
<span class="fc" id="L153">    return publish(topic, type, typeStr, buildOptions(options));</span>
  }

  public static native int publishEx(
      int topic, int type, String typeStr, String properties, PubSubOptions options);

  public static int publishEx(
      int topic, int type, String typeStr, String properties, PubSubOption... options) {
<span class="nc" id="L161">    return publishEx(topic, type, typeStr, properties, buildOptions(options));</span>
  }

  public static native void unpublish(int pubentry);

  public static native void releaseEntry(int entry);

  public static native void release(int pubsubentry);

  public static native int getTopicFromHandle(int pubsubentry);

  public static native int subscribeMultiple(int inst, String[] prefixes, PubSubOptions options);

  public static int subscribeMultiple(int inst, String[] prefixes, PubSubOption... options) {
<span class="nc" id="L175">    return subscribeMultiple(inst, prefixes, buildOptions(options));</span>
  }

  public static native void unsubscribeMultiple(int sub);

  public static native TimestampedBoolean getAtomicBoolean(
      int subentry, boolean defaultValue);

  public static native TimestampedBoolean[] readQueueBoolean(int subentry);

  public static native boolean[] readQueueValuesBoolean(int subentry);

  public static native boolean setBoolean(int entry, long time, boolean value);

  public static native boolean getBoolean(int entry, boolean defaultValue);

  public static native boolean setDefaultBoolean(int entry, long time, boolean defaultValue);


  public static native TimestampedInteger getAtomicInteger(
      int subentry, long defaultValue);

  public static native TimestampedInteger[] readQueueInteger(int subentry);

  public static native long[] readQueueValuesInteger(int subentry);

  public static native boolean setInteger(int entry, long time, long value);

  public static native long getInteger(int entry, long defaultValue);

  public static native boolean setDefaultInteger(int entry, long time, long defaultValue);


  public static native TimestampedFloat getAtomicFloat(
      int subentry, float defaultValue);

  public static native TimestampedFloat[] readQueueFloat(int subentry);

  public static native float[] readQueueValuesFloat(int subentry);

  public static native boolean setFloat(int entry, long time, float value);

  public static native float getFloat(int entry, float defaultValue);

  public static native boolean setDefaultFloat(int entry, long time, float defaultValue);


  public static native TimestampedDouble getAtomicDouble(
      int subentry, double defaultValue);

  public static native TimestampedDouble[] readQueueDouble(int subentry);

  public static native double[] readQueueValuesDouble(int subentry);

  public static native boolean setDouble(int entry, long time, double value);

  public static native double getDouble(int entry, double defaultValue);

  public static native boolean setDefaultDouble(int entry, long time, double defaultValue);


  public static native TimestampedString getAtomicString(
      int subentry, String defaultValue);

  public static native TimestampedString[] readQueueString(int subentry);

  public static native String[] readQueueValuesString(int subentry);

  public static native boolean setString(int entry, long time, String value);

  public static native String getString(int entry, String defaultValue);

  public static native boolean setDefaultString(int entry, long time, String defaultValue);


  public static native TimestampedRaw getAtomicRaw(
      int subentry, byte[] defaultValue);

  public static native TimestampedRaw[] readQueueRaw(int subentry);

  public static native byte[][] readQueueValuesRaw(int subentry);

  public static boolean setRaw(int entry, long time, byte[] value) {
<span class="nc" id="L258">    return setRaw(entry, time, value, 0, value.length);</span>
  }

  public static native boolean setRaw(int entry, long time, byte[] value, int start, int len);

  public static boolean setRaw(int entry, long time, ByteBuffer value) {
<span class="nc" id="L264">    int pos = value.position();</span>
<span class="nc" id="L265">    return setRaw(entry, time, value, pos, value.capacity() - pos);</span>
  }

  public static boolean setRaw(int entry, long time, ByteBuffer value, int start, int len) {
<span class="fc bfc" id="L269" title="All 2 branches covered.">    if (value.isDirect()) {</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">      if (start &lt; 0) {</span>
<span class="fc" id="L271">        throw new IndexOutOfBoundsException(&quot;start must be &gt;= 0&quot;);</span>
      }
<span class="fc bfc" id="L273" title="All 2 branches covered.">      if (len &lt; 0) {</span>
<span class="fc" id="L274">        throw new IndexOutOfBoundsException(&quot;len must be &gt;= 0&quot;);</span>
      }
<span class="fc bfc" id="L276" title="All 2 branches covered.">      if ((start + len) &gt; value.capacity()) {</span>
<span class="fc" id="L277">        throw new IndexOutOfBoundsException(&quot;start + len must be smaller than buffer capacity&quot;);</span>
      }
<span class="fc" id="L279">      return setRawBuffer(entry, time, value, start, len);</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">    } else if (value.hasArray()) {</span>
<span class="fc" id="L281">      return setRaw(entry, time, value.array(), value.arrayOffset() + start, len);</span>
    } else {
<span class="nc" id="L283">      throw new UnsupportedOperationException(&quot;ByteBuffer must be direct or have a backing array&quot;);</span>
    }
  }

  private static native boolean setRawBuffer(int entry, long time, ByteBuffer value, int start, int len);

  public static native byte[] getRaw(int entry, byte[] defaultValue);

  public static boolean setDefaultRaw(int entry, long time, byte[] defaultValue) {
<span class="nc" id="L292">    return setDefaultRaw(entry, time, defaultValue, 0, defaultValue.length);</span>
  }

  public static native boolean setDefaultRaw(int entry, long time, byte[] defaultValue, int start, int len);

  public static boolean setDefaultRaw(int entry, long time, ByteBuffer defaultValue) {
<span class="nc" id="L298">    int pos = defaultValue.position();</span>
<span class="nc" id="L299">    return setDefaultRaw(entry, time, defaultValue, pos, defaultValue.limit() - pos);</span>
  }

  public static boolean setDefaultRaw(int entry, long time, ByteBuffer defaultValue, int start, int len) {
<span class="nc bnc" id="L303" title="All 2 branches missed.">    if (defaultValue.isDirect()) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">      if (start &lt; 0) {</span>
<span class="nc" id="L305">        throw new IndexOutOfBoundsException(&quot;start must be &gt;= 0&quot;);</span>
      }
<span class="nc bnc" id="L307" title="All 2 branches missed.">      if (len &lt; 0) {</span>
<span class="nc" id="L308">        throw new IndexOutOfBoundsException(&quot;len must be &gt;= 0&quot;);</span>
      }
<span class="nc bnc" id="L310" title="All 2 branches missed.">      if ((start + len) &gt; defaultValue.capacity()) {</span>
<span class="nc" id="L311">        throw new IndexOutOfBoundsException(&quot;start + len must be smaller than buffer capacity&quot;);</span>
      }
<span class="nc" id="L313">      return setDefaultRawBuffer(entry, time, defaultValue, start, len);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">    } else if (defaultValue.hasArray()) {</span>
<span class="nc" id="L315">      return setDefaultRaw(entry, time, defaultValue.array(), defaultValue.arrayOffset() + start, len);</span>
    } else {
<span class="nc" id="L317">      throw new UnsupportedOperationException(&quot;ByteBuffer must be direct or have a backing array&quot;);</span>
    }
  }

  private static native boolean setDefaultRawBuffer(int entry, long time, ByteBuffer defaultValue, int start, int len);


  public static native TimestampedBooleanArray getAtomicBooleanArray(
      int subentry, boolean[] defaultValue);

  public static native TimestampedBooleanArray[] readQueueBooleanArray(int subentry);

  public static native boolean[][] readQueueValuesBooleanArray(int subentry);

  public static native boolean setBooleanArray(int entry, long time, boolean[] value);

  public static native boolean[] getBooleanArray(int entry, boolean[] defaultValue);

  public static native boolean setDefaultBooleanArray(int entry, long time, boolean[] defaultValue);


  public static native TimestampedIntegerArray getAtomicIntegerArray(
      int subentry, long[] defaultValue);

  public static native TimestampedIntegerArray[] readQueueIntegerArray(int subentry);

  public static native long[][] readQueueValuesIntegerArray(int subentry);

  public static native boolean setIntegerArray(int entry, long time, long[] value);

  public static native long[] getIntegerArray(int entry, long[] defaultValue);

  public static native boolean setDefaultIntegerArray(int entry, long time, long[] defaultValue);


  public static native TimestampedFloatArray getAtomicFloatArray(
      int subentry, float[] defaultValue);

  public static native TimestampedFloatArray[] readQueueFloatArray(int subentry);

  public static native float[][] readQueueValuesFloatArray(int subentry);

  public static native boolean setFloatArray(int entry, long time, float[] value);

  public static native float[] getFloatArray(int entry, float[] defaultValue);

  public static native boolean setDefaultFloatArray(int entry, long time, float[] defaultValue);


  public static native TimestampedDoubleArray getAtomicDoubleArray(
      int subentry, double[] defaultValue);

  public static native TimestampedDoubleArray[] readQueueDoubleArray(int subentry);

  public static native double[][] readQueueValuesDoubleArray(int subentry);

  public static native boolean setDoubleArray(int entry, long time, double[] value);

  public static native double[] getDoubleArray(int entry, double[] defaultValue);

  public static native boolean setDefaultDoubleArray(int entry, long time, double[] defaultValue);


  public static native TimestampedStringArray getAtomicStringArray(
      int subentry, String[] defaultValue);

  public static native TimestampedStringArray[] readQueueStringArray(int subentry);

  public static native String[][] readQueueValuesStringArray(int subentry);

  public static native boolean setStringArray(int entry, long time, String[] value);

  public static native String[] getStringArray(int entry, String[] defaultValue);

  public static native boolean setDefaultStringArray(int entry, long time, String[] defaultValue);


  public static native NetworkTableValue[] readQueueValue(int subentry);

  public static native NetworkTableValue getValue(int entry);

  public static native void setEntryFlags(int entry, int flags);

  public static native int getEntryFlags(int entry);

  public static native TopicInfo getTopicInfo(NetworkTableInstance inst, int topic);

  public static native int createListenerPoller(int inst);

  public static native void destroyListenerPoller(int poller);

  private static int kindsToMask(EnumSet&lt;NetworkTableEvent.Kind&gt; kinds) {
<span class="fc" id="L409">    int mask = 0;</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">    for (NetworkTableEvent.Kind kind : kinds) {</span>
<span class="fc" id="L411">      mask |= kind.getValue();</span>
<span class="fc" id="L412">    }</span>
<span class="fc" id="L413">    return mask;</span>
  }

  public static int addListener(int poller, String[] prefixes, EnumSet&lt;NetworkTableEvent.Kind&gt; kinds) {
<span class="fc" id="L417">    return addListener(poller, prefixes, kindsToMask(kinds));</span>
  }

  public static int addListener(int poller, int handle, EnumSet&lt;NetworkTableEvent.Kind&gt; kinds) {
<span class="fc" id="L421">    return addListener(poller, handle, kindsToMask(kinds));</span>
  }

  public static native int addListener(int poller, String[] prefixes, int mask);

  public static native int addListener(int poller, int handle, int mask);

  public static native NetworkTableEvent[] readListenerQueue(
      NetworkTableInstance inst, int poller);

  public static native void removeListener(int listener);

  public static native int getNetworkMode(int inst);

  public static native void startLocal(int inst);

  public static native void stopLocal(int inst);

  public static native void startServer(
      int inst, String persistFilename, String listenAddress, int port3, int port4);

  public static native void stopServer(int inst);

  public static native void startClient3(int inst, String identity);

  public static native void startClient4(int inst, String identity);

  public static native void stopClient(int inst);

  public static native void setServer(int inst, String serverName, int port);

  public static native void setServer(int inst, String[] serverNames, int[] ports);

  public static native void setServerTeam(int inst, int team, int port);

  public static native void disconnect(int inst);

  public static native void startDSClient(int inst, int port);

  public static native void stopDSClient(int inst);

  public static native void flushLocal(int inst);

  public static native void flush(int inst);

  public static native ConnectionInfo[] getConnections(int inst);

  public static native boolean isConnected(int inst);

  public static native OptionalLong getServerTimeOffset(int inst);

  public static native long now();

  private static native int startEntryDataLog(int inst, long log, String prefix, String logPrefix);

  public static int startEntryDataLog(int inst, DataLog log, String prefix, String logPrefix) {
<span class="nc" id="L477">    return startEntryDataLog(inst, log.getImpl(), prefix, logPrefix);</span>
  }

  public static native void stopEntryDataLog(int logger);

  private static native int startConnectionDataLog(int inst, long log, String name);

  public static int startConnectionDataLog(int inst, DataLog log, String name) {
<span class="nc" id="L485">    return startConnectionDataLog(inst, log.getImpl(), name);</span>
  }

  public static native void stopConnectionDataLog(int logger);

  public static native int addLogger(int poller, int minLevel, int maxLevel);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NetworkTableListenerPoller.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ntcore</a> &gt; <a href="index.source.html" class="el_package">edu.wpi.first.networktables</a> &gt; <span class="el_source">NetworkTableListenerPoller.java</span></div><h1>NetworkTableListenerPoller.java</h1><pre class="source lang-java linenums">// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package edu.wpi.first.networktables;

import java.util.EnumSet;

/**
 * Event listener poller. This queues events matching the specified mask. Code using the listener
 * must periodically call readQueue() to read the events.
 */
public final class NetworkTableListenerPoller implements AutoCloseable {
  /**
   * Construct a topic listener poller.
   *
   * @param inst Instance
   */
<span class="fc" id="L19">  public NetworkTableListenerPoller(NetworkTableInstance inst) {</span>
<span class="fc" id="L20">    m_inst = inst;</span>
<span class="fc" id="L21">    m_handle = NetworkTablesJNI.createListenerPoller(inst.getHandle());</span>
<span class="fc" id="L22">  }</span>

  /**
   * Start listening to topic changes for topics with names that start with any of the given
   * prefixes. This creates a corresponding internal subscriber with the lifetime of the listener.
   *
   * @param prefixes Topic name string prefixes
   * @param eventKinds set of event kinds to listen to
   * @return Listener handle
   */
  public int addListener(String[] prefixes, EnumSet&lt;NetworkTableEvent.Kind&gt; eventKinds) {
<span class="nc" id="L33">    return NetworkTablesJNI.addListener(m_handle, prefixes, eventKinds);</span>
  }

  /**
   * Start listening to changes to a particular topic. This creates a corresponding internal
   * subscriber with the lifetime of the listener.
   *
   * @param topic Topic
   * @param eventKinds set of event kinds to listen to
   * @return Listener handle
   */
  public int addListener(Topic topic, EnumSet&lt;NetworkTableEvent.Kind&gt; eventKinds) {
<span class="nc" id="L45">    return NetworkTablesJNI.addListener(m_handle, topic.getHandle(), eventKinds);</span>
  }

  /**
   * Start listening to topic changes on a subscriber. This does NOT keep the subscriber active.
   *
   * @param subscriber Subscriber
   * @param eventKinds set of event kinds to listen to
   * @return Listener handle
   */
  public int addListener(Subscriber subscriber, EnumSet&lt;NetworkTableEvent.Kind&gt; eventKinds) {
<span class="nc" id="L56">    return NetworkTablesJNI.addListener(m_handle, subscriber.getHandle(), eventKinds);</span>
  }

  /**
   * Start listening to topic changes on a subscriber. This does NOT keep the subscriber active.
   *
   * @param subscriber Subscriber
   * @param eventKinds set of event kinds to listen to
   * @return Listener handle
   */
  public int addListener(MultiSubscriber subscriber, EnumSet&lt;NetworkTableEvent.Kind&gt; eventKinds) {
<span class="nc" id="L67">    return NetworkTablesJNI.addListener(m_handle, subscriber.getHandle(), eventKinds);</span>
  }

  /**
   * Start listening to topic changes on an entry.
   *
   * @param entry Entry
   * @param eventKinds set of event kinds to listen to
   * @return Listener handle
   */
  public int addListener(NetworkTableEntry entry, EnumSet&lt;NetworkTableEvent.Kind&gt; eventKinds) {
<span class="nc" id="L78">    return NetworkTablesJNI.addListener(m_handle, entry.getHandle(), eventKinds);</span>
  }

  /**
   * Add a connection listener. The callback function is called asynchronously on a separate thread,
   * so it's important to use synchronization or atomics when accessing any shared state from the
   * callback function.
   *
   * @param immediateNotify notify listener of all existing connections
   * @return Listener handle
   */
  public int addConnectionListener(boolean immediateNotify) {
<span class="nc" id="L90">    EnumSet&lt;NetworkTableEvent.Kind&gt; eventKinds = EnumSet.of(NetworkTableEvent.Kind.kConnection);</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">    if (immediateNotify) {</span>
<span class="nc" id="L92">      eventKinds.add(NetworkTableEvent.Kind.kImmediate);</span>
    }
<span class="nc" id="L94">    return NetworkTablesJNI.addListener(m_handle, m_inst.getHandle(), eventKinds);</span>
  }

  /**
   * Add a time synchronization listener. The callback function is called asynchronously on a
   * separate thread, so it's important to use synchronization or atomics when accessing any shared
   * state from the callback function.
   *
   * @param immediateNotify notify listener of current time synchronization value
   * @return Listener handle
   */
  public int addTimeSyncListener(boolean immediateNotify) {
<span class="fc" id="L106">    EnumSet&lt;NetworkTableEvent.Kind&gt; eventKinds = EnumSet.of(NetworkTableEvent.Kind.kTimeSync);</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">    if (immediateNotify) {</span>
<span class="nc" id="L108">      eventKinds.add(NetworkTableEvent.Kind.kImmediate);</span>
    }
<span class="fc" id="L110">    return NetworkTablesJNI.addListener(m_handle, m_inst.getHandle(), eventKinds);</span>
  }

  /**
   * Add logger callback function. By default, log messages are sent to stderr; this function sends
   * log messages with the specified levels to the provided callback function instead. The callback
   * function will only be called for log messages with level greater than or equal to minLevel and
   * less than or equal to maxLevel; messages outside this range will be silently ignored.
   *
   * @param minLevel minimum log level
   * @param maxLevel maximum log level
   * @return Listener handle
   */
  public int addLogger(int minLevel, int maxLevel) {
<span class="nc" id="L124">    return NetworkTablesJNI.addLogger(m_handle, minLevel, maxLevel);</span>
  }

  /**
   * Remove a listener.
   *
   * @param listener Listener handle
   */
  public void removeListener(int listener) {
<span class="nc" id="L133">    NetworkTablesJNI.removeListener(listener);</span>
<span class="nc" id="L134">  }</span>

  /**
   * Read topic notifications.
   *
   * @return Topic notifications since the previous call to readQueue()
   */
  public NetworkTableEvent[] readQueue() {
<span class="fc" id="L142">    return NetworkTablesJNI.readListenerQueue(m_inst, m_handle);</span>
  }

  @Override
  public synchronized void close() {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">    if (m_handle != 0) {</span>
<span class="fc" id="L148">      NetworkTablesJNI.destroyListenerPoller(m_handle);</span>
    }
<span class="fc" id="L150">    m_handle = 0;</span>
<span class="fc" id="L151">  }</span>

  /**
   * Determines if the native handle is valid.
   *
   * @return True if the native handle is valid, false otherwise.
   */
  public boolean isValid() {
<span class="nc bnc" id="L159" title="All 2 branches missed.">    return m_handle != 0;</span>
  }

  /**
   * Gets the native handle.
   *
   * @return Handle
   */
  public int getHandle() {
<span class="nc" id="L168">    return m_handle;</span>
  }

  private final NetworkTableInstance m_inst;
  private int m_handle;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>